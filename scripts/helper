#!/bin/bash
#
# Helper script for uefi-manager privileged operations.
# Executed via pkexec to run commands as root.
#
# Only commands in the whitelist are permitted.

set -euo pipefail

# Allowed command basenames
ALLOWED_COMMANDS=(
    blkid cp cryptsetup cut df efibootmgr findmnt grep lsblk
    mkdir mount mountpoint rm rmdir sfdisk umount
)

# Allowed full-path commands
ALLOWED_PATHS=(
    /usr/lib/uefi-manager/uefimanager-lib
)

is_allowed() {
    local cmd="$1"
    local base
    if ! base="$(basename -- "$cmd" 2>/dev/null)"; then
        base="$cmd"
    fi

    for allowed in "${ALLOWED_COMMANDS[@]}"; do
        [[ "$base" == "$allowed" ]] && return 0
    done
    for allowed in "${ALLOWED_PATHS[@]}"; do
        [[ "$cmd" == "$allowed" ]] && return 0
    done
    return 1
}

trim_whitespace() {
    local value="$1"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"
    printf '%s' "$value"
}

split_segments() {
    local input="$1"
    local segment=""
    local in_single=0
    local in_double=0
    local escaped=0
    local i char next

    for ((i = 0; i < ${#input}; ++i)); do
        char="${input:i:1}"

        if ((escaped)); then
            segment+="$char"
            escaped=0
            continue
        fi

        if ((in_single)); then
            segment+="$char"
            [[ "$char" == "'" ]] && in_single=0
            continue
        fi

        if ((in_double)); then
            segment+="$char"
            if [[ "$char" == '"' ]]; then
                in_double=0
            elif [[ "$char" == "\\" ]] && ((i + 1 < ${#input})); then
                ((++i))
                segment+="${input:i:1}"
            fi
            continue
        fi

        case "$char" in
            "\\")
                segment+="$char"
                escaped=1
                ;;
            "'")
                segment+="$char"
                in_single=1
                ;;
            '"')
                segment+="$char"
                in_double=1
                ;;
            ";")
                printf '%s\n' "$segment"
                segment=""
                ;;
            "|")
                printf '%s\n' "$segment"
                segment=""
                next="${input:i+1:1}"
                if [[ "$next" == "|" ]]; then
                    ((++i))
                fi
                ;;
            "&")
                printf '%s\n' "$segment"
                segment=""
                next="${input:i+1:1}"
                if [[ "$next" == "&" ]]; then
                    ((++i))
                fi
                ;;
            *)
                segment+="$char"
                ;;
        esac
    done

    if ((in_single || in_double || escaped)); then
        echo "Error: malformed command string" >&2
        return 1
    fi

    printf '%s\n' "$segment"
}

if [[ $# -eq 0 ]]; then
    echo "Error: no command provided" >&2
    exit 1
fi

# Fast path for procAsRoot(command, args): no shell parsing required.
if [[ $# -gt 1 ]]; then
    cmd="$1"
    shift
    if ! is_allowed "$cmd"; then
        echo "Error: command not permitted: $cmd" >&2
        exit 1
    fi
    exec "$cmd" "$@"
fi

# runAsRoot(commandString) path; command may contain pipes/conditionals.
cmd_string="$1"

# Reject empty or whitespace-only command strings
if [[ -z "${cmd_string// /}" ]]; then
    echo "Error: empty command string" >&2
    exit 1
fi

# Block shell features that can execute hidden commands.
if [[ "$cmd_string" == *'$('* || "$cmd_string" == *'`'* || "$cmd_string" == *'<('* || "$cmd_string" == *'>('* ]]; then
    echo "Error: command string contains forbidden shell constructs" >&2
    exit 1
fi

# Block I/O redirections outside of quotes (could write to arbitrary files).
{
    local_in_sq=0 local_in_dq=0 local_esc=0
    for ((j = 0; j < ${#cmd_string}; ++j)); do
        c="${cmd_string:j:1}"
        if ((local_esc)); then local_esc=0; continue; fi
        if ((local_in_sq)); then [[ "$c" == "'" ]] && local_in_sq=0; continue; fi
        if ((local_in_dq)); then
            if [[ "$c" == '"' ]]; then local_in_dq=0;
            elif [[ "$c" == "\\" ]]; then local_esc=1; fi
            continue
        fi
        case "$c" in
            "\\") local_esc=1 ;;
            "'")  local_in_sq=1 ;;
            '"')  local_in_dq=1 ;;
            ">"| "<")
                echo "Error: I/O redirections are not permitted" >&2
                exit 1
                ;;
        esac
    done
}

# Extract and validate every command in the pipeline/chain.
while IFS= read -r segment; do
    segment="$(trim_whitespace "$segment")"
    [[ -z "$segment" ]] && continue
    read -r cmd_word _ <<< "$segment"
    [[ -z "$cmd_word" ]] && continue
    # Strip surrounding quotes so that e.g. 'grep' or "grep" matches the allowlist
    cmd_word="${cmd_word#\"}" ; cmd_word="${cmd_word%\"}"
    cmd_word="${cmd_word#\'}" ; cmd_word="${cmd_word%\'}"
    if ! is_allowed "$cmd_word"; then
        echo "Error: command not permitted: $cmd_word" >&2
        exit 1
    fi
done < <(split_segments "$cmd_string")

exec /bin/bash -o pipefail -c "$cmd_string"
